(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{1094:function(_,v,s){"use strict";s.r(v);var r=s(6),t=Object(r.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"_1-redis-有了解么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis-有了解么"}},[_._v("#")]),_._v(" 1. Redis 有了解么？")]),_._v(" "),s("p",[_._v("答：redis（Remote Dictionary Server远程字典服务）是一款高性能的分布式"),s("strong",[_._v("内存数据库")]),_._v("，是"),s("strong",[_._v("基于内存运行并支持持久化的 NoSQL 数据库")]),_._v("。")]),_._v(" "),s("p",[_._v("Redis 支持丰富的数据类型，支持数据持久化、事务、主从复制、哨兵模式......")]),_._v(" "),s("h2",{attrs:{id:"redis-与-memcached-相比有什么优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-与-memcached-相比有什么优势"}},[_._v("#")]),_._v(" Redis 与 memcached 相比有什么优势？")]),_._v(" "),s("ul",[s("li",[_._v("数据类型：memcached 所有值均是简单字符串；redis 支持更加丰富的数据类型")]),_._v(" "),s("li",[_._v("数据备份：redis 支持数据备份")]),_._v(" "),s("li",[_._v("运行速度：redis 速度比 memcached 快，并且支持数据持久化")]),_._v(" "),s("li",[_._v("底层模型：底层使用模型不同，redis 自己构建了 VM 管理机制")]),_._v(" "),s("li",[_._v("value大小：value 大小不同，redis 可达 512M；memcached 只有 1M")])]),_._v(" "),s("h2",{attrs:{id:"redis-支持哪些数据类型-应用场景有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-支持哪些数据类型-应用场景有哪些"}},[_._v("#")]),_._v(" Redis 支持哪些数据类型？应用场景有哪些？")]),_._v(" "),s("ul",[s("li",[s("p",[s("strong",[_._v("String")])]),_._v(" "),s("ul",[s("li",[_._v("字符串 value 的最大值为 512M")]),_._v(" "),s("li",[_._v("常用来做一些计数功能的缓存")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("List")])]),_._v(" "),s("ul",[s("li",[_._v("按插入顺序排序，可以添加一个元素到列表的头部或尾部")]),_._v(" "),s("li",[_._v("底层为一个链表")]),_._v(" "),s("li",[_._v("可以实现简单消息队列功能，做基于 redis 的分页功能")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("Set")])]),_._v(" "),s("ul",[s("li",[_._v("字符串类型的无序集合")]),_._v(" "),s("li",[_._v("可用来全局去重")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("Zset")])]),_._v(" "),s("ul",[s("li",[_._v("字符串类型的有序集合，每一个元素配有一个 score 来保持顺序")]),_._v(" "),s("li",[_._v("可以用来做排行榜应用或者进行范围查找")])])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("Hash")])]),_._v(" "),s("ul",[s("li",[_._v("键值对集合")]),_._v(" "),s("li",[_._v("用来存放对象")])])])]),_._v(" "),s("h2",{attrs:{id:"redis-配置文件有了解么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-配置文件有了解么"}},[_._v("#")]),_._v(" Redis 配置文件有了解么？")]),_._v(" "),s("p",[_._v("答：常用模块如下")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("NETWORK")]),_._v("：配置 redis 服务器地址，端口，超时时间等")]),_._v(" "),s("li",[s("strong",[_._v("GENERAL")]),_._v("：配置日志文件的路径和日志级别等")]),_._v(" "),s("li",[s("strong",[_._v("SNAPSHOTTING")]),_._v("：RDB 持久化配置信息")]),_._v(" "),s("li",[s("strong",[_._v("REPLICATION")]),_._v("：redis 集群配置信息")]),_._v(" "),s("li",[s("strong",[_._v("MEMORY MANAGEMENT")]),_._v("：内存管理，包括数据过期删除策略等信息的设置")]),_._v(" "),s("li",[s("strong",[_._v("APPEND ONLY MODE")]),_._v("：AOF 持久化配置信息")])]),_._v(" "),s("h1",{attrs:{id:"_2-redis-是单线程的么-为什么执行速度这么快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis-是单线程的么-为什么执行速度这么快"}},[_._v("#")]),_._v(" 2. Redis 是单线程的么？为什么执行速度这么快？")]),_._v(" "),s("p",[_._v("答：")]),_._v(" "),s("p",[_._v("redis 是"),s("strong",[_._v("单线程")]),_._v("的。redis 的单线程指网络请求模块使用了一个线程，所以不需要考虑并发安全性。")]),_._v(" "),s("p",[_._v("但是对于需要依赖多个操作的复合操作来说，可能需要分布式锁。")]),_._v(" "),s("p",[_._v("redis 执行速度快基于以下原因：")]),_._v(" "),s("ul",[s("li",[_._v("基于内存实现，完全内存计算")]),_._v(" "),s("li",[_._v("单线程操作，避免上下文切换")]),_._v(" "),s("li",[_._v("多路 I/O 复用的线程模型，实现了一个线程监控多个 IO 流，及时响应请求")]),_._v(" "),s("li",[_._v("redis 对外部依赖小，属于轻量级的内存数据库")])]),_._v(" "),s("h1",{attrs:{id:"_3-使用-redis-可能出现的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用-redis-可能出现的问题"}},[_._v("#")]),_._v(" 3. 使用 Redis 可能出现的问题")]),_._v(" "),s("p",[_._v("答："),s("strong",[_._v("缓存雪崩、缓存击穿、缓存穿透、数据库和缓存的双写一致性问题")])]),_._v(" "),s("h2",{attrs:{id:"缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[_._v("#")]),_._v(" 缓存雪崩")]),_._v(" "),s("p",[_._v("概述：缓存雪崩指缓存在同一时间大面积的失效，而此时又有大量的请求发送到数据库上，导致数据库连接异常。")]),_._v(" "),s("p",[_._v("解决方法：可以给缓存设置不同的缓存时间，更新数据使用互斥锁，或者通过双缓存避免缓存雪崩。")]),_._v(" "),s("h2",{attrs:{id:"缓存击穿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[_._v("#")]),_._v(" 缓存击穿")]),_._v(" "),s("p",[_._v("概述：redis 中存储的是热点数据，当高并发请求访问 redis 中的热点数据时，若 redis 中的数据过期了，就会造成缓存击穿现象，请求穿过缓存直接打在了数据库上。")]),_._v(" "),s("p",[_._v("解决方法：使用互斥锁，只让一个请求去load DB，成功之后重新写缓存。而其他的请求没有获取到互斥锁，可以尝试重新获取缓存中的数据。")]),_._v(" "),s("h2",{attrs:{id:"缓存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[_._v("#")]),_._v(" 缓存穿透")]),_._v(" "),s("p",[_._v("概述：故意去请求缓存中不存在的数据，导致请求全部打在数据库上，导致数据库异常。")]),_._v(" "),s("p",[_._v("解决方法：可以使用互斥锁，或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制（例如布隆过滤器）来拦截不合法的 key 值。")]),_._v(" "),s("h2",{attrs:{id:"数据库和缓存的双写一致性问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库和缓存的双写一致性问题"}},[_._v("#")]),_._v(" 数据库和缓存的双写一致性问题")]),_._v(" "),s("p",[_._v("概述：在高并发请求下容易导致数据不一致的问题，若业务需要强一致性，建议不使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。")]),_._v(" "),s("p",[_._v("解决方法：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("双删延迟")]),_._v("：可以先删除缓存数据，再更新数据库。最后再间隔固定的时间去再次删除缓存。")]),_._v(" "),s("li",[s("strong",[_._v("更新数据库产生的binlog订阅（使用canal）")]),_._v("：如果上次删除缓存失败，则将有变化的 key 记录下来，并且尝试去不断的删除缓存。")])]),_._v(" "),s("h1",{attrs:{id:"_4-redis-的持久化方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis-的持久化方式有哪些"}},[_._v("#")]),_._v(" 4. Redis 的持久化方式有哪些？")]),_._v(" "),s("p",[_._v("答："),s("strong",[_._v("RDB 和 AOF")])]),_._v(" "),s("h2",{attrs:{id:"rdb-全量持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb-全量持久化"}},[_._v("#")]),_._v(" RDB（全量持久化）")]),_._v(" "),s("p",[s("strong",[_._v("触发方式")])]),_._v(" "),s("ul",[s("li",[_._v("自动触发：在配置文件中可以配置执行多少次 save 就自动触发持久化")]),_._v(" "),s("li",[_._v("手动触发：通过 bgsave 指令，可以 fork 一个子进程负责异步生成快照")])]),_._v(" "),s("p",[s("strong",[_._v("快照恢复")])]),_._v(" "),s("p",[_._v("将备份文件更名为 dump.rdb 并移动到 redis 安装目录，redis 在启动时会自动加载快照文件数据到内存。")]),_._v(" "),s("p",[s("strong",[_._v("优缺点分析")])]),_._v(" "),s("ul",[s("li",[_._v("RDB 持久化方式存在数据丢失，因为其不是实时的实现持久化（会丢失最后一次持久化之后的数据）。")]),_._v(" "),s("li",[_._v("每一次执行 bgsave 都需要 fork 一个子进程，属于重量级操作，频繁执行的成本过高，会影响系统性能。自动触发同样存在部分数据丢失的问题。")]),_._v(" "),s("li",[_._v("对数据准确性要求不高且恢复大数据集时，RDB 速度快于 AOF。")])]),_._v(" "),s("h2",{attrs:{id:"aof-增量持久化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aof-增量持久化"}},[_._v("#")]),_._v(" AOF（增量持久化）")]),_._v(" "),s("p",[_._v("AOF 需要在配置文件中手动开启。")]),_._v(" "),s("p",[s("strong",[_._v("AOF 日志重写")])]),_._v(" "),s("ul",[s("li",[_._v("随着服务器的运行，AOF 文件会越来越大，可以通过 AOF 重写来控制其大小。")]),_._v(" "),s("li",[_._v("AOF 重写会首先读取数据库中现有的键值对状态，然后根据类型使用一条命令来代替前面对键值对操作的多条命令，达到压缩大小的效果。")]),_._v(" "),s("li",[_._v("使用 bgrewriteaof 命令实现 AOF 重写。")])]),_._v(" "),s("p",[s("strong",[_._v("AOF 重写缓存区")])]),_._v(" "),s("p",[_._v("redis 是单线程工作，当AOF文件较大时重写时间会比较长，在重写 AOF 期间，redis将长时间无法处理客户端请求。为了解决这个问题，可以将 AOF 重写程序放到子进程中执行。")]),_._v(" "),s("p",[_._v("优点：")]),_._v(" "),s("ul",[s("li",[_._v("子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其它客户端请求。")]),_._v(" "),s("li",[_._v("子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。")])]),_._v(" "),s("p",[s("strong",[_._v("子进程 AOF 重写导致的问题")])]),_._v(" "),s("p",[_._v("子进程在进行 AOF 重写期间，服务器进程依然可以处理其它客户端请求，这就会导致数据库状态已经发生了改变，使得当前数据库数据状态和重写后的 AOF 文件中的数据不一致。")]),_._v(" "),s("p",[_._v("解决方法：")]),_._v(" "),s("ul",[s("li",[_._v("redis 服务器设置了一个 AOF 重写缓冲区。这个缓冲区在创建子进程后开始使用，当redis服务器执行一个客户端的写请求命令，之后将这个写命令也发送到 AOF 重写缓冲区。")]),_._v(" "),s("li",[_._v("当子进程完成 AOF 日志重写之后，给父进程发送信号，父进程接收此信号后，将 AOF 重写缓冲区的内容写到新的 AOF 文件中，保持数据的一致性。")])]),_._v(" "),s("p",[s("strong",[_._v("优缺点分析")])]),_._v(" "),s("ul",[s("li",[_._v("AOF 可以做到秒级持久化，使用追加写的方式来写入，可读性强。且当文件毁坏时，还可以使用命令进行文件修复。")]),_._v(" "),s("li",[_._v("相比 RDB，同样的数据量的情况下 AOF 文件体积更大。在 redis 负载较高时，秒级更新 AOF 文件会影响性能。")])]),_._v(" "),s("h2",{attrs:{id:"持久化策略选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#持久化策略选择"}},[_._v("#")]),_._v(" 持久化策略选择")]),_._v(" "),s("ul",[s("li",[_._v("AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢也更加完整。")]),_._v(" "),s("li",[_._v("RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小并且恢复速度较快。")])]),_._v(" "),s("h1",{attrs:{id:"_5-redis-数据的过期回收策略与内存淘汰机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-redis-数据的过期回收策略与内存淘汰机制"}},[_._v("#")]),_._v(" 5. Redis 数据的过期回收策略与内存淘汰机制")]),_._v(" "),s("h2",{attrs:{id:"过期回收策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#过期回收策略"}},[_._v("#")]),_._v(" 过期回收策略")]),_._v(" "),s("p",[_._v("redis 中的数据过期回收策略使用了定期删除和惰性删除相结合的方式。")]),_._v(" "),s("ul",[s("li",[s("p",[s("strong",[_._v("定期删除")]),_._v("：redis 每隔一段时间去抽查一定量的数据判断其是否过期，若过期则进行删除。")])]),_._v(" "),s("li",[s("p",[s("strong",[_._v("惰性删除")]),_._v("：在获取一个 key 时，redis 会检查这个 key 是否已经过期，若过期则会进行删除操作。")])])]),_._v(" "),s("h2",{attrs:{id:"内存淘汰机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰机制"}},[_._v("#")]),_._v(" 内存淘汰机制")]),_._v(" "),s("p",[_._v("在配置文件中，我们可以对内存淘汰机制进行配置。当内存使用达到最大值时，redis 可以使用的清除策略如下：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("volatile-lru")]),_._v("：利用 LRU 算法移除设置过过期时间的 key（LRU：最近使用，least Recently Used）")]),_._v(" "),s("li",[s("strong",[_._v("allkeys-lru")]),_._v("：利用 LRU 算法移除任何 key")]),_._v(" "),s("li",[s("strong",[_._v("volatile-random")]),_._v("：移除设置过过期时间的随机 key")]),_._v(" "),s("li",[s("strong",[_._v("allkeys-random")]),_._v("：移除随机 key")]),_._v(" "),s("li",[s("strong",[_._v("volatile-ttl")]),_._v("：移除即将过期的 key")]),_._v(" "),s("li",[s("strong",[_._v("noeviction")]),_._v("：不移除任何 key，只是返回一个写错误，为默认选项")])]),_._v(" "),s("h1",{attrs:{id:"_6-redis-主从复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-redis-主从复制"}},[_._v("#")]),_._v(" 6. Redis 主从复制")]),_._v(" "),s("p",[_._v("答：")]),_._v(" "),s("p",[_._v("当项目较大时，可以使用"),s("strong",[_._v("主从架构 Master/Slave 机制")]),_._v("。其中 Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置自动同步到从机 Slave 节点。")]),_._v(" "),s("p",[_._v("主从复制的原理包括"),s("strong",[_._v("旧版同步")]),_._v("和"),s("strong",[_._v("命令传播")]),_._v("，其代价是系统复制较重是会导致主从延迟，且根据 CAP 理论，"),s("strong",[_._v("无法同时保证高可用性和一致性")]),_._v("。")]),_._v(" "),s("h1",{attrs:{id:"_7-redis-对事务的支持"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-redis-对事务的支持"}},[_._v("#")]),_._v(" 7. Redis 对事务的支持")]),_._v(" "),s("p",[_._v("答：redis 事务有三大特性："),s("strong",[_._v("单独的隔离操作、没有隔离级别的概念、不保证原子性")]),_._v("。")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("单独的隔离操作")]),_._v("：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。")]),_._v(" "),s("li",[s("strong",[_._v("没有隔离级别的概念")]),_._v("：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题")]),_._v(" "),s("li",[s("strong",[_._v("不保证原子性")]),_._v("：redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚")])]),_._v(" "),s("h2",{attrs:{id:"事务操作的相关命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事务操作的相关命令"}},[_._v("#")]),_._v(" 事务操作的相关命令")]),_._v(" "),s("table",[s("thead",[s("tr",[s("th",[_._v("命令")]),_._v(" "),s("th",[_._v("描述")])])]),_._v(" "),s("tbody",[s("tr",[s("td",[_._v("discard")]),_._v(" "),s("td",[_._v("取消事务，放弃执行事务块内的所有命令")])]),_._v(" "),s("tr",[s("td",[_._v("exec")]),_._v(" "),s("td",[_._v("执行事务块内的所有命令")])]),_._v(" "),s("tr",[s("td",[_._v("multi")]),_._v(" "),s("td",[_._v("标记一个事务块的开始")])]),_._v(" "),s("tr",[s("td",[_._v("unwatch")]),_._v(" "),s("td",[_._v("取消watch命令对所有key的监视")])]),_._v(" "),s("tr",[s("td",[_._v("watch key [key...]")]),_._v(" "),s("td",[_._v("监视一个或者多个key，如果事务执行之前这些key被其他命令所改动，那么事务将会被打断")])])])]),_._v(" "),s("h1",{attrs:{id:"_8-redis-如何实现分布式锁-如何加锁解锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-redis-如何实现分布式锁-如何加锁解锁"}},[_._v("#")]),_._v(" 8. Redis 如何实现分布式锁？如何加锁解锁？")]),_._v(" "),s("h1",{attrs:{id:"_9-redis-的哨兵模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-redis-的哨兵模式"}},[_._v("#")]),_._v(" 9. Redis 的哨兵模式")]),_._v(" "),s("p",[_._v("答：")]),_._v(" "),s("p",[_._v("哨兵模式即使用一组 sentinel 监控多个 master，是反客为主的自动版，能够在后台监控主库的运行状态，如果主库宕机则采取投票的方式自动选取一个从库转换为主库。")]),_._v(" "),s("p",[_._v("使用：")]),_._v(" "),s("ol",[s("li",[s("p",[_._v("新建 sentinel.conf 文件，并配置内容 "),s("code",[_._v("sentinel monitor <master-group-name> <ip> <port> <quorum>")])])]),_._v(" "),s("li",[s("p",[_._v("使用"),s("strong",[_._v("redis-server sentinel.conf --sentinel")]),_._v("命令启动哨兵")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);