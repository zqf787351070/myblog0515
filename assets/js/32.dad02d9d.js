(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{1123:function(_,t,v){"use strict";v.r(t);var a=v(6),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"_1-锁概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁概述"}},[_._v("#")]),_._v(" 1. 锁概述")]),_._v(" "),a("p",[_._v("锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。")]),_._v(" "),a("p",[_._v("在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。")]),_._v(" "),a("h1",{attrs:{id:"_2-锁的分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-锁的分类"}},[_._v("#")]),_._v(" 2. 锁的分类")]),_._v(" "),a("p",[_._v("从对数据操作的粒度分 ：")]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("表锁")]),_._v("：操作时，会锁定整个表。")]),_._v(" "),a("li",[a("strong",[_._v("行锁")]),_._v("：操作时，会锁定当前操作行。")])]),_._v(" "),a("p",[_._v("从对数据操作的类型分：")]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("读锁（共享锁）")]),_._v("：针对同一份数据，多个读操作可以同时进行而")]),_._v(" "),a("li",[a("strong",[_._v("写锁（排它锁）")]),_._v("：当前操作没有完成之前，它会阻断其他写锁和读锁。")])]),_._v(" "),a("p",[_._v("MySQL 锁及其特点：")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("存储引擎")]),_._v(" "),a("th",[_._v("表级锁")]),_._v(" "),a("th",[_._v("行级锁")]),_._v(" "),a("th",[_._v("页面锁")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("MyISAM")]),_._v(" "),a("td",[_._v("支持")]),_._v(" "),a("td",[_._v("不支持")]),_._v(" "),a("td",[_._v("不支持")])]),_._v(" "),a("tr",[a("td",[_._v("InnoDB")]),_._v(" "),a("td",[_._v("支持")]),_._v(" "),a("td",[_._v("支持")]),_._v(" "),a("td",[_._v("不支持")])])])]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("锁类型")]),_._v(" "),a("th",[_._v("特点")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("表级锁")]),_._v(" "),a("td",[_._v("偏向 MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。")])]),_._v(" "),a("tr",[a("td",[_._v("行级锁")]),_._v(" "),a("td",[_._v("偏向 InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。")])]),_._v(" "),a("tr",[a("td",[_._v("页面锁")]),_._v(" "),a("td",[_._v("开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。")])])])]),_._v(" "),a("h1",{attrs:{id:"_3-myisam-表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-myisam-表锁"}},[_._v("#")]),_._v(" 3. MyISAM 表锁")]),_._v(" "),a("p",[_._v("MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型。")]),_._v(" "),a("p",[_._v("MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁；在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁。")]),_._v(" "),a("p",[_._v("这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。")]),_._v(" "),a("p",[_._v("显示加表锁语法：")]),_._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[_._v("加读锁 ： "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("lock")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("table")]),_._v(" table_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("read")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n加写锁 ： "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("lock")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("table")]),_._v(" table_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("write")]),_._v("；\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br"),a("span",{staticClass:"line-number"},[_._v("2")]),a("br")])]),a("h2",{attrs:{id:"_3-1-读锁示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-读锁示例"}},[_._v("#")]),_._v(" 3.1 读锁示例")]),_._v(" "),a("p",[a("img",{attrs:{src:v(993),alt:"b5a021165c0bc9496d25483c1c6071e1.png"}})]),_._v(" "),a("h2",{attrs:{id:"_3-2-写锁示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-写锁示例"}},[_._v("#")]),_._v(" 3.2 写锁示例")]),_._v(" "),a("p",[a("img",{attrs:{src:v(994),alt:"b721f3eaf214a713fba307a294c85516.png"}})]),_._v(" "),a("h2",{attrs:{id:"_3-3-结论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-结论"}},[_._v("#")]),_._v(" 3.3 结论")]),_._v(" "),a("p",[a("strong",[_._v("读锁会阻塞写，但不会阻塞读；写锁既会阻塞读，又会阻塞写")])]),_._v(" "),a("h2",{attrs:{id:"_3-4-查看锁的争用情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-查看锁的争用情况"}},[_._v("#")]),_._v(" 3.4 查看锁的争用情况")]),_._v(" "),a("p",[a("img",{attrs:{src:v(995),alt:"56d78e39ef309789d4548b21236a00a3.png"}})]),_._v(" "),a("ul",[a("li",[a("code",[_._v("In_use")]),_._v("：表当前被查询使用的次数。若为0则表是打开的，但是当前没有被使用")]),_._v(" "),a("li",[a("code",[_._v("Name_locked")]),_._v("：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作")])]),_._v(" "),a("p",[a("img",{attrs:{src:v(996),alt:"c6af7397d33ca8619e8e2d1e4d5d942a.png"}})]),_._v(" "),a("ul",[a("li",[a("code",[_._v("Table_locks_immediate")]),_._v("：指能够立刻获得表级锁的次数，每次立即获取锁，该值+1")]),_._v(" "),a("li",[a("code",[_._v("Table_locks_waited")]),_._v("：指不能立刻获取表级锁而需要等待的次数，每等待一次，该值+1。该值高说明存在着较为严重的表级锁争用情况")])]),_._v(" "),a("h1",{attrs:{id:"_4-innodb-行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-innodb-行锁"}},[_._v("#")]),_._v(" 4. InnoDB 行锁")]),_._v(" "),a("p",[_._v("行锁特点：")]),_._v(" "),a("ul",[a("li",[_._v("开销大、加锁慢")]),_._v(" "),a("li",[_._v("会出现死锁")]),_._v(" "),a("li",[_._v("锁的细粒度最小，发生锁冲突的概率最低")]),_._v(" "),a("li",[_._v("并发度最高\nInnoDB 和 MyISAM 的不同：")]),_._v(" "),a("li",[_._v("支持事务")]),_._v(" "),a("li",[_._v("采用行级锁")])]),_._v(" "),a("h2",{attrs:{id:"_4-1-背景知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-背景知识"}},[_._v("#")]),_._v(" 4.1 背景知识")]),_._v(" "),a("h3",{attrs:{id:"事务及其-acid-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务及其-acid-属性"}},[_._v("#")]),_._v(" 事务及其 ACID 属性")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("ACID")]),_._v(" "),a("th",[_._v("含义")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("Atomicity 原子性")]),_._v(" "),a("td",[_._v("事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败")])]),_._v(" "),a("tr",[a("td",[_._v("Consistent 一致性")]),_._v(" "),a("td",[_._v("在事务开始和完成时，数据都必须保持一致状态")])]),_._v(" "),a("tr",[a("td",[_._v("Isolation 隔离性")]),_._v(" "),a("td",[_._v("数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立环境”下运行")])]),_._v(" "),a("tr",[a("td",[_._v("Durable 持久性")]),_._v(" "),a("td",[_._v("事务完成之后，对于数据的修改是永久的")])])])]),_._v(" "),a("h3",{attrs:{id:"并发事务处理带来的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发事务处理带来的问题"}},[_._v("#")]),_._v(" 并发事务处理带来的问题")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("问题")]),_._v(" "),a("th",[_._v("含义")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("丢失更新(Lost Update)")]),_._v(" "),a("td",[_._v("当两个或多个事务选择同一行，最初事务修改的值会被后面事务修改的值覆盖")])]),_._v(" "),a("tr",[a("td",[_._v("脏读(Dirty Reads)")]),_._v(" "),a("td",[_._v("当一个事务正在访问数据，并且对数据进行了修改，而这个修改还没有提交到数据库中，此时另一个事务也访问到这个数据，并使用了这个数据")])]),_._v(" "),a("tr",[a("td",[_._v("不可重复读(Non-Repetable Reads)")]),_._v(" "),a("td",[_._v("一个事物在读取某些数据后的某个时间再次读取以前读过的数据，发现和之前不一样")])]),_._v(" "),a("tr",[a("td",[_._v("幻读(Phantom Reads)")]),_._v(" "),a("td",[_._v("一个事物按照相同的查询条件重新读取以前查询过的数据，却发现被其他事务插入了满足查询条件的新数据")])])])]),_._v(" "),a("h3",{attrs:{id:"事务隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[_._v("#")]),_._v(" 事务隔离级别")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("隔离级别")]),_._v(" "),a("th",[_._v("丢失更新")]),_._v(" "),a("th",[_._v("脏读")]),_._v(" "),a("th",[_._v("不可重复读")]),_._v(" "),a("th",[_._v("幻读")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("Read uncommitted")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("✔")]),_._v(" "),a("td",[_._v("✔")]),_._v(" "),a("td",[_._v("✔")])]),_._v(" "),a("tr",[a("td",[_._v("Read committeed")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("✔")]),_._v(" "),a("td",[_._v("✔")])]),_._v(" "),a("tr",[a("td",[_._v("Repeatable read (默认)")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("✔")])]),_._v(" "),a("tr",[a("td",[_._v("Serializable")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")]),_._v(" "),a("td",[_._v("×")])])])]),_._v(" "),a("h3",{attrs:{id:"查看当前数据库的隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看当前数据库的隔离级别"}},[_._v("#")]),_._v(" 查看当前数据库的隔离级别")]),_._v(" "),a("h2",{attrs:{id:"_4-2-innodb-的行锁模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-innodb-的行锁模式"}},[_._v("#")]),_._v(" 4.2 InnoDB 的行锁模式")]),_._v(" "),a("p",[_._v("InnoDB 实现了以下两种类型的行锁：")]),_._v(" "),a("ul",[a("li",[a("strong",[_._v("共享锁(S)")]),_._v("：又称为读锁，简称 S 锁。共享锁就是多个事务对于同一个数据可以共享一把锁，都能访问到数据，但是只能读不能修改。")]),_._v(" "),a("li",[a("strong",[_._v("排它锁(X)")]),_._v("：又称写锁，简称 X 锁。排它锁不能与其他锁并存，如果一个事务获取了一个数据行的排它锁，其他事物就不能再获取该行的其他锁，包括共享锁和排它锁。获取排它锁的事务可以对数据进行读取和修改。\n对于 "),a("code",[_._v("UPDATE / DELETE / INSERT")]),_._v("，InnoDB 会自动给涉及数据集加排它锁。")])]),_._v(" "),a("p",[_._v("对于普通的 SELECT，InnoDB 不会加任何锁。")]),_._v(" "),a("h2",{attrs:{id:"_4-3-行锁演示"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-行锁演示"}},[_._v("#")]),_._v(" 4.3 行锁演示")]),_._v(" "),a("p",[a("img",{attrs:{src:v(997),alt:"58e13d3622f72c6f19dcd10721ade214.png"}})]),_._v(" "),a("h2",{attrs:{id:"_4-4-无索引航说升级为表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-无索引航说升级为表锁"}},[_._v("#")]),_._v(" 4.4 无索引航说升级为表锁")]),_._v(" "),a("p",[_._v("若不通过索引条件进行数据检索，那么 InnoDB 将对表中的所有记录加锁，实际效果跟表锁一样。")]),_._v(" "),a("h2",{attrs:{id:"_4-5-间隙锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-间隙锁"}},[_._v("#")]),_._v(" 4.5 间隙锁")]),_._v(" "),a("p",[_._v("当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁。")]),_._v(" "),a("p",[_._v('对于键值在条件范围内但并不存在的记录，叫做"间隙（GAP）"， InnoDB 也会对这个 "间隙" 加锁，这种锁机制就是所谓的'),a("strong",[_._v("间隙锁（Next-Key锁）")])]),_._v(" "),a("p",[a("img",{attrs:{src:v(998),alt:"da8c22d7d260442bbaf90ecd9bdbd7fe.png"}})]),_._v(" "),a("h2",{attrs:{id:"_4-6-innodb-行锁的争用情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-innodb-行锁的争用情况"}},[_._v("#")]),_._v(" 4.6 InnoDB 行锁的争用情况")]),_._v(" "),a("p",[a("img",{attrs:{src:v(999),alt:"d8550ab8d1ec0774e9bf56f6c6109ced.png"}})]),_._v(" "),a("ul",[a("li",[_._v("Innodb_row_lock_current_waits: 当前正在等待锁定的数量")]),_._v(" "),a("li",[_._v("Innodb_row_lock_time: 从系统启动到现在锁定总时间长度")]),_._v(" "),a("li",[_._v("Innodb_row_lock_time_avg:每次等待所花平均时长")]),_._v(" "),a("li",[_._v("Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间")]),_._v(" "),a("li",[_._v("Innodb_row_lock_waits: 系统启动后到现在总共等待的次数")])]),_._v(" "),a("p",[_._v("当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。")]),_._v(" "),a("h1",{attrs:{id:"_5-总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[_._v("#")]),_._v(" 5. 总结")]),_._v(" "),a("p",[_._v("InnoDB 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于 MyISAM 的表锁的。当系统并发量较高的时候， InnoDB 的整体性能和 MyISAM 相比就会有比较明显的优势。")]),_._v(" "),a("p",[_._v("但是，InnoDB 的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差。")])])}),[],!1,null,null,null);t.default=s.exports},993:function(_,t,v){_.exports=v.p+"assets/img/b5a021165c0bc9496d25483c1c6071e1.b5a02116.png"},994:function(_,t,v){_.exports=v.p+"assets/img/b721f3eaf214a713fba307a294c85516.b721f3ea.png"},995:function(_,t,v){_.exports=v.p+"assets/img/56d78e39ef309789d4548b21236a00a3.56d78e39.png"},996:function(_,t,v){_.exports=v.p+"assets/img/c6af7397d33ca8619e8e2d1e4d5d942a.c6af7397.png"},997:function(_,t,v){_.exports=v.p+"assets/img/58e13d3622f72c6f19dcd10721ade214.58e13d36.png"},998:function(_,t,v){_.exports=v.p+"assets/img/da8c22d7d260442bbaf90ecd9bdbd7fe.da8c22d7.png"},999:function(_,t,v){_.exports=v.p+"assets/img/d8550ab8d1ec0774e9bf56f6c6109ced.d8550ab8.png"}}]);